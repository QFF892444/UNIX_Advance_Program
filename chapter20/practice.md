# 习题

## 第20章

20.1 _db_dodelete中保守的加锁操作时为了避免和db_nextrec发起竞争条件。如果没有使用写锁保护_db_writedat 调用，则有可能在db_nextrec读某个记录时，该记录已被删除：db_nextrec首先读入一个索引记录，判定该记录为空，接着读数据记录，但是在它调用_db_readidx和_db_readidx之间，该记录却可能被_db_dodelete删除了。

20.2 假定db_nextrec调用_db_readidx，它将记录的键读入索引缓冲区。然后，该进程被内核调度进程暂停，另一个进程运行，它刚好调用db_delete删除这一条记录，使得索引文件和数据记录文件中对应部分都被清空。当第一个进程恢复执行并调用_db_readdat时，返回的是空数据记录。db_nextrec中的读锁使得读入索引记录的过程和读入数据的过程是一个原子操作。

20.3 强制性锁对其他的读进程和写进程产生了影响。在_db_writeidx和_db_writedat设置的锁被解除之前，其他的读操作和写操作都将被阻塞。

20.4 ignore

20.5 在写索引记录之前写数据记录，通过这一方法来防止如下情形：若该进程在两次写之间被杀死从而产生不正常的记录。如果进程先写索引记录，而在写数据记录之前被杀死，那么就会得到一个有效的索引记录，但它却指向一个无效的数据记录。

20.6 ignore

20.7 ignore

20.8 ignore

20.9 ignore

20.10 ignore
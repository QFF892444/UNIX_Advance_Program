# 习题

## 第十五章

15.1 如果管道的写端总是不关闭,则读者就决不会看到文件结束符.分页程序就会一直阻塞在读标准输入.

15.2 父进程向管道写完最后一行以后就终止,当父进程终止时管道的读端自动关闭.但是由于子进程要等待输入的页,所以父进程可能比子进程领先一个管道缓冲区.如果正在运行的是一个可对命令行进行编辑的交互式shell,那么当父进程终止时,shell多半会改变终端的模式并打印一个提示.无疑会影响已经对终端模式进行修改的分页程序.

15.3 因为执行了shell,所以popen返回一个文件指针.但是shell不能执行不存在的命令,因此标准错误上打印下面信息后终止:
        sh: line 1: ./a.out: No such file or directory

15.4 当父进程终止时,用shell看他的终止状态.所用的命令时 echo $?,打印的结果是128加信号编号

15.5 见源程序 coprocess_add2_std.c

15.6 system函数调用了wait,终止的第一个子进程是由popen产生的.因为该子进程不是system创建的,所以它将再次调用wait并一直阻塞到sleep完成.然后system返回.当pclose调用wait时,由于没有子进程可等待所以返回错误,导致pclose也返回错误.

15.7 select表明描述符是可读的.调用read读完所有的数据后,返回0就表明到达了文件尾端.但对于poll来说,若返回POLLHUP事件,则表明也许仍有数据可读.但是一旦读完所有数据,read就返回0表明到达文件尾端.在读完了所有数据后,POLLIN事件就不会再返回了,即使需要再调用一次read以接收文件尾端通知.

15.8 子进程向标准错误写的内容同意也会在父进程的标准错误中出现.只要在cmdstring中包含shell重定向2>&1,就可以将标准错误发回父进程.

15.9 popen函数fork一个子进程,子进程执行shell.然后shell再调用fork,最后由shell的子进程执行命令串.当cmdstring终止时,shell恰好在等待该事件.然后shell退出,而这一事件有是pclose中的waitpid所等待的.

15.10 解决的办法是打开FIFO两次:一次读一次写.不会使用为写而打开描述符,但使该描述符打开就可在客户数从1变成0时,阻止产生文件尾端.打开FIFO两次需要注意:第一次以非阻塞,只读方式打开;第二次以阻塞,只写方式打开.然后关闭描述符的非阻塞属性.
    见源程序 nonblock_fifo.c

15.11 随意读取现行队列中的消息会干扰客户进程-服务器进程协议,导致丢失客户进程请求或者服务器进程的响应.只要知道队列的标识符或者该队列的标识符或者该队列运允许所有的用户读,进程就可以读队列.

15.12 略

15.13 由于服务器进程和各客户进程可能会将段连接到不同的地址,所以在共享存储段中绝不会存储实际物理地址.相反,当在共享存储段中建立链表时,链表指针的值会设置为共享存储段内另一对象的偏移量.偏移量为所指对象的实际地址减去共享存储段的起始地址.

15.14 略

15.15 略

15.16 略

15.17 见源程序 flock_sync.c

15.18 见源程序 sem_sync.c
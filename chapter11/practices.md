# 习题

## 第十一章

11.1 见源程序 pthread_exit_11_4.c

11.2 要改变挂起作业的线程ID,必须持有写模式下的读写锁,防止ID在改变过程中有其他线程在搜索该列表.目前定义该接口的方式存在的问题在于:调用job_find找到该作业以及调用job_remove从列表中删除该作业这两个时间之间作业ID可以改动.这个问题可以通过job结构中嵌入引用计数和互斥量,然后让job_find增加引用计数的方法来解决.

11.3 列表是由读写锁保护的,但条件变量需要互斥量对条件进行保护.其次每个线程等待满足的条件应该是有某个作业进行处理时需要的条件,所以需要创建每线程数据结构来表示这个条件.或者,可以把互斥量和条件量嵌入到queue结构中,但这意味着所有的工作线程将等待相同的条件.如果有很多工作线程存在,当唤醒了许多线程但又没有工作可做时,就可能出现惊群效应,最后导致CPU资源浪费,并且增加了锁的争夺.

11.4 两种情况都是正确的,但每一种方法都有缺陷.第一种方法,等待线程会被安排在调用pthread_cond_broadcast之后运行.如果程序运行的处理器上,由于还持有互斥锁(pthread_cond_wait返回持有的互斥锁),一些线程就会运行而且马上阻塞.第二种方法,运行线程在第三和第四步之间获取互斥锁,然后使条件失效,最后释放互斥锁.接着,当调用pthread_cond_broadcast时,条件不再为真,线程无需运行.这就是为什么唤醒线程必须重新检查条件,不能仅仅因为pthread_cond_wait返回就是假定条件为真.

11.5 可以使用 pthread_cond_wait 、pthread_cond_broadcast 和 pthread_mutex_lock 结合实现，每个线程调用 pthread_barrier_wait 时，加锁递减一个条件变量的值，并检查是否等于 0，若不等于，就 pthread_cond_wait，若等于 0，那么 pthread_cond_broadcast。

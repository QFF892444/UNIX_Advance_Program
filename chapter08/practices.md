# 习题

## 第八章

8.1 这里假设子进程调用exit函数时关闭标准I/O流，但不关闭文件描述符STDOUT_FILENO。有些版本的标准I/O库会关闭与标准输出相关联的文件描述符从而引起write标准输出失败。这种情况下，调用dup将标准输出复制到另一个文件描述符，write则使用新复制的文件描述法进行标准输出。
    见源代码fork_use_prac1.c

8.2 见源程序vfork_error.c

8.3 函数f1调用vfork时，父进程的栈指针指向f1的函数的栈帧，vfork使得子进程先执行然后从f1返回，接着子进程调用f2，并且f2的栈帧覆盖了f1的栈帧，在f2中进程将自动变量buf的值设为0，即将栈中的1000个字节的值都设置为0。 从f2返回后子进程调用_exit，这时栈中main栈帧一下的内容已经被f2修改了。然后，父进程从vfork调用后回复继续，并从f1返回。

8.4 执行完第一个 ./a.out 之后父进程先终止还是子进程先执行，这两者执行的先后顺序出现竞争，依赖于内核调度。父进程先执行，会干扰上一个子进程的输出，导致输出混乱。如果子进程先输出，同理也有可能造成输出混乱。

8.5 argv[2]的输出和调用execl时一样，也是输出 /home/sar/bin/testinterp。
原因：execlp 在结束时调用execve，并且与直接调用execl的路径名相同。

8.6 见源程序dead_process.c

8.7 见源程序opendir_info.c
